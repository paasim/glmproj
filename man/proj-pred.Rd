% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{proj-pred}
\alias{proj-pred}
\alias{proj_linpred}
\alias{proj_predict}
\title{Predictions from a projected submodel}
\usage{
proj_linpred(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  transform = FALSE,
  integrated = FALSE,
  ...
)

proj_predict(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  nresample_clusters = 1000,
  ppd_seed = NULL,
  ...
)
}
\arguments{
\item{object}{Either an object returned by \link[=project]{project} or
alternatively any object that can be passed to argument \code{object} of
\link[=project]{project}.}

\item{newdata}{The predictor values used in the prediction. If
\code{solution_terms} is specified, then \code{newdata} should either be a
dataframe containing column names that correspond to \code{solution_terms}
or a matrix with the number and order of columns corresponding to
\code{solution_terms}. If \code{solution_terms} is unspecified, then
\code{newdata} must either be a dataframe containing all the column names
as in the original data or a matrix with the same columns at the same
positions as in the original data.}

\item{offsetnew}{Offsets for the new observations. By default a vector of
zeros. By default we take the offsets from newdata as in the original
model. Either NULL or right hand side formula.}

\item{weightsnew}{Weights for the new observations. For binomial model,
corresponds to the number trials per observation. For \code{proj_linpred},
this argument matters only if \code{newdata} is specified. By default we
take the weights from newdata as in the original model. Either NULL or
right hand side formula.}

\item{filter_nterms}{Only applies if \code{object} is an object returned by
\link[=project]{project}. In that case, \code{filter_nterms} can be used to
filter \code{object} for only those elements (submodels) with a number of
solution terms in \code{filter_nterms}. Therefore, needs to be a numeric
vector or \code{NULL}. If \code{NULL}, use all submodels.}

\item{transform}{Should the linear predictor be transformed using the
inverse-link function? Default is \code{FALSE}. For \code{proj_linpred}
only.}

\item{integrated}{If \code{TRUE}, the output is averaged over the projected
posterior draws. Default is \code{FALSE}. For \code{proj_linpred} only.}

\item{...}{Additional arguments passed to \link{project} if \code{object} is
not already an object returned by \link{project}.}

\item{nresample_clusters}{For \code{proj_predict} with clustered projection
only: Number of draws to return from the predictive distribution of the
projection. Not to be confused with argument \code{nclusters} of
\link{project}: \code{nresample_clusters} gives the number of draws
(\emph{with} replacement) from the set of clustered posterior draws after
projection (as determined by argument \code{nclusters} of \link{project}).}

\item{ppd_seed}{For \code{proj_predict} only: An optional seed for drawing
from the posterior predictive distribution. If a clustered projection was
performed, \code{ppd_seed} is also used for drawing from the set of
clustered posterior draws after projection (see argument
\code{nresample_clusters}).}
}
\value{
If the prediction is done for one submodel only (i.e., \code{nterms}
  has length one or \code{solution_terms} is specified):
  \itemize{
    \item \code{proj_linpred} returns a \code{list} with elements \code{pred}
    (predictions) and \code{lpd} (log predictive densities). Each of these
    two elements is a \eqn{S \times N}{S x N} matrix.
    \item \code{proj_predict} returns a \eqn{S \times N}{S x N} matrix of
    predictions.
  }
  Thereby, \eqn{S} denotes the number of (possibly clustered) projected
  posterior draws and \eqn{N} denotes the number of observations.

  If the prediction is done for more than one submodel, the output from above
  is returned for each submodel, giving a named \code{list} with one element
  for each submodel (the names of this \code{list} being the numbers of
  solutions terms of the submodels when counting the intercept, too).
}
\description{
\code{proj_linpred} gives draws of the linear predictor (possibly transformed
to response scale) of a projected submodel (i.e., a submodel resulting from
projecting the reference model onto it). \code{proj_predict} draws from the
predictive distribution of a projected submodel. If the projection has not
been performed, both functions also perform the projection. Both functions
can also handle multiple projected submodels at once (if the input object is
of class \code{"vsel"}).
}
\examples{
\donttest{
if (requireNamespace("rstanarm", quietly = TRUE)) {
  # Data:
  n <- 30
  d <- 5
  x <- matrix(rnorm(n * d), nrow = n)
  y <- x[, 1] + rnorm(n, sd = 0.5)
  data <- data.frame(x, y)

  # Reference model (here an object of class "stanreg"):
  fit <- rstanarm::stan_glm(y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(),
                            data = data, chains = 2, iter = 500, seed = 1235)

  # Variable selection (here without cross-validation, but only for the sake
  # of speed in this demonstration):
  vs <- varsel(fit)

  # Predictions (at the training points) from the projected submodels
  # corresponding to the first 4 selected predictor terms:
  pred <- proj_linpred(vs, nterms = 4)
  pred <- proj_predict(vs, nterms = 4)
}
}

}
