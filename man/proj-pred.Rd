% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{proj-pred}
\alias{proj-pred}
\alias{proj_linpred}
\alias{proj_predict}
\title{Extract draws of the linear predictor and draw from the predictive
distribution of the projected submodel}
\usage{
proj_linpred(
  object,
  nterms_filter = NULL,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  transform = FALSE,
  integrated = FALSE,
  ...
)

proj_predict(
  object,
  nterms_filter = NULL,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  size_sub = 1000,
  seed_sub = NULL,
  ...
)
}
\arguments{
\item{object}{Either an object returned by \link[=project]{project} or
alternatively any object that can be passed to argument \code{object} of
\link[=project]{project}.}

\item{nterms_filter}{Only applies if \code{object} is an object returned by
\link[=project]{project}. In that case, \code{nterms_filter} can be used to
filter \code{object} for only those elements (submodels) with a number of
solution terms in \code{nterms_filter}. Therefore, needs to be a numeric
vector or \code{NULL}. If \code{NULL}, use all submodels.}

\item{newdata}{The predictor values used in the prediction. If
\code{solution_terms} is specified, then \code{newdata} should either be a
dataframe containing column names that correspond to \code{solution_terms}
or a matrix with the number and order of columns corresponding to
\code{solution_terms}. If \code{solution_terms} is unspecified, then
\code{newdata} must either be a dataframe containing all the column names
as in the original data or a matrix with the same columns at the same
positions as in the original data.}

\item{offsetnew}{Offsets for the new observations. By default a vector of
zeros. By default we take the weights from newdata as in the original
model. Either NULL or right hand side formula.}

\item{weightsnew}{Weights for the new observations. For binomial model,
corresponds to the number trials per observation. For \code{proj_linpred},
this argument matters only if \code{newdata} is specified. By default we
take the weights from newdata as in the original model. Either NULL or
right hand side formula.}

\item{transform}{Should the linear predictor be transformed using the
inverse-link function? Default is \code{FALSE}. For \code{proj_linpred}
only.}

\item{integrated}{If \code{TRUE}, the output is averaged over the projected
posterior draws. Default is \code{FALSE}. For \code{proj_linpred} only.}

\item{...}{Additional arguments passed to \link{project} if \code{object} is
not already an object returned by \link{project}.}

\item{size_sub}{For \code{proj_predict} only: Number of draws to return from
the predictive distribution of the projection. Not to be confused with
arguments \code{ndraws} and \code{nclusters} of \link{project}:
\code{size_sub} gives a \emph{subset} of the (possibly clustered) posterior
draws after projection (as determined by arguments \code{ndraws} and
\code{nclusters} of \link{project}). The default for \code{size_sub} is
1000. We compute as many clusters from the reference posterior as draws, so
we end up projecting a single draw from each cluster.}

\item{seed_sub}{For \code{proj_predict} only: An optional seed for subsetting
the (possibly clustered) posterior draws after projection (see argument
\code{size_sub}).}
}
\value{
If the prediction is done for one submodel only (\code{nterms} has
  length one or \code{solution_terms} is specified):
  \itemize{
    \item \code{proj_linpred} returns a list with elements \code{pred}
    (predictions) and \code{lpd} (log predictive densities). Both elements
    are either a S x N matrix or a length-N vector (depending on the value of
    \code{integrated}), with S denoting the number of (possibly clustered)
    posterior draws and N denoting the number of observations.
    \item \code{proj_predict} returns a S x N matrix of predictions, with S
    denoting the number of (possibly clustered) posterior draws and N
    denoting the number of observations.
  }
  If the predictions are done for several submodel sizes, the output from
  above is returned for each submodel (giving a list of length equal to the
  number of submodels).
}
\description{
\code{proj_linpred} extracts draws of the linear predictor and
\code{proj_predict} draws from the predictive distribution of the projected
submodel or submodels. If the projection has not been performed, the
functions also perform the projection.
}
\examples{
\donttest{
if (requireNamespace('rstanarm', quietly=TRUE)) {
  ### Usage with stanreg objects
  n <- 30
  d <- 5
  x <- matrix(rnorm(n*d), nrow=n)
  y <- x[,1] + 0.5*rnorm(n)
  data <- data.frame(x,y)

  fit <- rstanarm::stan_glm(y ~ X1 + X2 + X3 + X4 + X5, gaussian(), data=data, chains=2, iter=500)
  vs <- varsel(fit)

  # compute predictions with 4 variables at the training points
  pred <- proj_linpred(vs, newdata = data, nv = 4)
  pred <- proj_predict(vs, newdata = data, nv = 4)
}
}

}
